\chapter{Background}
As mentioned in Chapter~\ref{chapter:intro}, JavaScript has several shortcommings. Two of the tools that will be used in this project are Haste~\cite{haste-lang} and JSFlow~\cite{jsflow,jsflow-csf12,jsflow-sac14}.
\section{Problems with JavaScript - part deux}
As mentioned in Chapter~\ref{chapter:intro}, from a security standpoint JavaScript suffers from weak dynamic typing and having access to sensitive information in the browser.
\subsection{Weak dynamic typing}
There are several odd features one can use in JavaScript due to the weak dynamic typing. Where a statically typed language (e.g. Java) would give a compile error, the JavaScript code will be run and perhaps succeed but with unexpected results. Figure~\ref{fig:error_java} shows a logical error that is caught at compile time in Java. If the code in Figure~\ref{fig:error_java} would be allowed to run, it would be up to the runtime environment to determine how the code would be interpreted. The same error in JavaScript i shown in Figure~\ref{fig:error_js}. Since JavaScript does not have any static type checking the decision on how to interpret the code will be made at runtime. Instead of failing and raising a runtime error, JavaScript will convert the \textbf{true} value into a number which in this case corresponds to the number \textbf{1}. Hence the addition will be evaluated to \textbf{3}. Situatuations like that, where a clear type error is allowed to propagate and potentially change the state of the application should be considered dangerous and prone to producing bugs.

Another issue with the weak type system in JavaScript can be seen in Figure~\ref{fig:js_comparison}. It is perfectly legal to compare a function with an array in JavaScript. The code in Figure~\ref{fig:js_comparison} will evaluate to \textbf{true}. This can in turn make it very difficult to find potential bugs since JavaScript will try and convert values of different types to the same types and then make the comparison. In e.g. Java, the comparison in Figure~\ref{fig:js_comparison} would not go through the type checker.
\begin{figure}[h]
  \lstset{language=Java}
  \begin{lstlisting}
    int a = 2;
    boolean b = true;
    a + b;  // This should not be allowed to be run
  \end{lstlisting}
  \caption{Logical error in Java}
  \label{fig:error_java}
\end{figure}
\begin{figure}[h]
  \begin{lstlisting}
    var a = 2;
    var b = true;
    a + b;  // This will evaluate to 3
  \end{lstlisting}
  \caption{Logical error in JavaScript}
  \label{fig:error_js}
\end{figure}
\begin{figure}[h]
  \begin{lstlisting}
    (function(x) { return x * x; }) > [1,2,3];
  \end{lstlisting}
  \caption{Weird comparison in JavaScript}
  \label{fig:js_comparison}
\end{figure}

\subsection{Sensitive information in the browser}
The browser has access to several different types of sensitive information and can be used by an attacker to get the sensitive information. JavaScript can gain access to e.g. cookies, send HTTP requests and make arbitrary DOM modifications. If untrusted JavaScript is executed in a victims browser, the attacker can, among other things, perform the following attacks:
\begin{itemize}
  \item \textbf{Cookie theft}, where the attacker can gain access to the victim's cookies that are associated with the current website.
  \item \textbf{Keylogging}, where the attacker can create and register a keyboard event listener and send the keystrokes to the attacker's own server in order to potentially record passwords, credit card information etc.
  \item \textbf{Phishing}, where the attacker can insert fake forms by manipulating the DOM and fool the user to submit sensitive information which will be redirected to the attacker.
\end{itemize}
\subsection{Examples of attempts to solutions}
There have been several attempts of providing a more secure type system to JavaScript, everything from creating a statically typed language that compiles to JavaScript to a compiler from an already existing programming language and compile it to JavaScript to a static type checker. Examples of attempted soultions are
\begin{itemize}
  \item \textbf{TypeScript}~\cite{typescript}, a typed superset of JavaScript that compiles to plain JavaScript.
  \item \textbf{TeJaS}~\cite{tejas-art,tejas-git}, which allows you to annotate type signatures as comments in the JavaScript code and then type checks the code.
  \item \textbf{GHCJS}~\cite{ghcjs} and \textbf{Haste}~\cite{haste-lang,haste-symposium}, which compiles from Haskell, a statically typed, high-level functional programming language~\cite{haskell}, to JavaScript.
\end{itemize}

When looking at the other major flaw, namely that JavaScript has access to sensitive information that is stored within the browser, the current solution as of now is to sandbox the script and run it in a secure environment. There are mainly three ways of doing this.
\begin{itemize}
  \item Wrap the script inside a call to with and pass a faked window object and execute the code with eval.
  \item Use an iframe and set the sandbox attribute to either not allow scripts to run or have it be run within that iframe only. Unfortunately, as explained in~\cite{js_in_js}, iframes have some issues as well.
  \item Use existing tools to help sandbox third party code, such as:
    \begin{itemize}
      \item \textbf{JavaScript in JavaScript}~\cite{js_in_js}, an interpreter that allows an application to execute third-party scripts in a completely isolated, sandboxed environment.
      \item \textbf{Caja}~\cite{caja_spec}, a compiler to make third party code safe to embed within a website.
    \end{itemize}
\end{itemize}
\section{Haste}
Haste (HaSkell To Ecmascript compiler) is a compiler that compiles the high-level language Haskell to JavaScript. The Haste compiler is plugged in to the compilation process from GHC, the Glasgow Haskell Compiler. As can be seen in Figure~\ref{fig:system}, Haste starts its compiling process after GHC has done som code optimization. From the optimized code from GHC, Haste will create an AST, Abstract Syntax Tree, for JavaScript. The AST will then be optimized and after the optimization process in Haste is done the actual JavaScript code will be generated.
\begin{figure}[h]
  \begin{tabular}{|c|c|c|}
    \hline
    Step & Operation & GHC/Haste \\
    \hline
    1 & Parse & GHC \\
    2 & Type check & GHC \\
    3 & Desugar & GHC \\
    4 & Intermediate code generation & GHC \\
    5 & Optimization & GHC \\
    6 & Intermediate code generation (JS AST) & Haste \\
    7 & Optimization & Haste \\
    8 & Code generation to JavaScript & Haste \\
    \hline
  \end{tabular}
  \caption{The compilation process for the Haste compiler}
  \label{fig:system}
\end{figure}

When compiling the Haskell source code with Haste, the compilation process will result in one binary file for the server and source code in JavaScript for the client~\cite{haste-symposium}.

\section{JSFlow}
JSFlow is an interpreter written in JavaScript that dynamically checks the JavaScript code at runtime to ensure information-flow security. Currently, JSFlow supports full information-flow control for ecma-262 v5 apart from strict mode. Also, the publicly available version of JSON is not supported.

Within information-flow security, there are two types of flow that must be checked - explicit flow and implicit flow. Even though there are several different ways an attacker can gain information about a system (e.g. via timing attacks), only explicit and implicit flows for computations will be considered. An implementation that guarantees that timing attacks are not able to succeed will not be given for this project.
\subsection{Explicit flow}
With explicit flow, one means when a data in a \emph{high} context leaks information to a \emph{low} context explicitly. An example can be seen in Figure~\ref{fig:expflow} where the value of the high variable \emph{h} is leaked to the low variable \emph{l}. Obviously this should be illegal when information-flow security is applied and explicit flows are not difficult to find when dynamically checking the code. When data is written to a variable, one simply must keep track of the context of the variable and the context of the data. If the variable is in low context and the data is in high context an error should be produced and execution of the JavaScript code should be stopped. All other scenarios (high variable with high data, high variable with low data and low variable with low data) are allowed.
\subsection{Implicit flow}
\label{chapter:implicit_flow}
Implicit flows occurs when e.g. a language's control structure is used to leak information. Figure~\ref{fig:impflow} shows an example of an implicit flow. The variable \emph{l} will get the value 1 if and only if the variable \emph{h} is an odd number. Otherwise \emph{l} will have the value 0. A dynamic system that will handle implicit flows must associate a security context with the control flow~\cite{jsflow-csf12}. In Figure~\ref{fig:impflow}, the body of the if statement should be executed in a secure context and therefor the variable \emph{l} must be a secure variable in order for the flow to be valid.

\begin{figure}[h]
  \captionsetup[subfigure]{singlelinecheck=off,justification=raggedright}
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{lstlisting}
      l := h
    \end{lstlisting}
    \caption{Explicit flow}
    \label{fig:expflow}
  \end{subfigure}
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{lstlisting}
      h := h mod 2;
      l := 0;
      if h = 1 then l := 1;
      else skip;
    \end{lstlisting}
    \caption{Implicit flow}
    \label{fig:impflow}
  \end{subfigure}
  \caption{Implicit and explicit flow}
\end{figure}

\subsection{Example of coding towards JSFlow}
When creating a web application in JavaScript that JSFlow should be able to check, there is only one function that the programmer must know about - the \emph{upg} function. The function upg is used when lifting a computation in to a high context. In Figure~\ref{fig:upg}, the variable \emph{h} is lifted in to a high context by calling upg on the data to be stored to \emph{h}. Due to the call to upg, the variable h will be a high variable containing the number 42. As can be seen with the variables \emph{l}, which is a low variable, and \emph{t}, which is a high variable, the default level for a compuation is low unless JSFlow infers that a variable \textbf{must} be high due to part of the compuation being high.

\begin{figure}[h]
  \begin{lstlisting}
    // Variable l is a low variable of value 2
    var l = 2;

    // Variable h is a high variable of value 42
    var h = upg(42);

    /* Variable t must be a high variable due to h
       being high */
    var t = l + h;
  \end{lstlisting}
  \caption{Creating high and low variables in JavaScript with JSFlow}
  \label{fig:upg}
\end{figure}
The upg function will take a computation (in Figure~\ref{fig:upg} the compuation is simply the number 42) and bind that value to the assigned variable (in Figure~\ref{fig:upg} the variable h) and put the variable in a high context.

\subsection{Flows in a pure functional language}
Even though there are two different flows in Javascript (implicit and explicit flows), there is only one type of flow in a pure functional programming language like Haskell, an explicit flow~\cite{seclib}. As described in Chapter~\ref{chapter:implicit_flow}, an implicit flow depends on control structures in order to leak information. However, even though a pure functional programming language like Haskell contains control structures, they are still interpreted as a regular function. This means that a function like
\begin{center}
  \begin{lstlisting}[language=Haskell]
    f :: Int -> Int
    f x = if x `mod` 2 == 0
              then 42
            else -42
  \end{lstlisting}
\end{center}
will look like an implicit flow but is in fact an explicit flow. This is because an if-then-else can be rewritten as a regular function~\cite{if-then-else}
\begin{center}
  \begin{lstlisting}[language=Haskell]
    myIf :: Bool -> a -> a -> a
    myIf True  b1 _ = b1
    myIf False _ b2 = b2
  \end{lstlisting}
\end{center}
where b1 and b2 are the different branches. The different branches are of type \textbf{a}, which in this case can be any arbitrary expression. Rewriting the function \textbf{f} using \textbf{myIf} can be done as follows:
\begin{center}
  \begin{lstlisting}[language=Haskell]
    f :: Int -> Int
    f x = myIf (x `mod` 2 == 0) 42 (-42)
  \end{lstlisting}
\end{center}

\section{Non-Interference}
Something about non-interference. Public outcomes does not depend on private input.

Assume the following function where something of type \textbf{Char} is a high value and something of type \textbf{Int} is of low value:
\begin{center}
  \begin{lstlisting}[language=Haskell]
    fOk :: (Char, Int) -> (Char, Int)
    fOk (c, i) = (chr (ord c + i), i + 42)
  \end{lstlisting}
\end{center}
The function \textbf{f} does not leak any valuable information about the value \textbf{c} but rather preserves the confidentiality. The function \textbf{fOk} is \emph{non-interfered} since the public result (the Int value) is independent of the value of \textbf{c}. If the function was defined as
\begin{center}
  \begin{lstlisting}[language=Haskell]
    fBad1 :: (Char, Int) -> (Char, Int)
    fBad1 (c, i) = (c, ord c)
  \end{lstlisting}
\end{center}
it would not be non-interfered because the confidentiality is broken. Information about \textbf{c} is leaked through the low Int and the corresponding decimal value of the ASCII number of \textbf{c} is returned as the second value of the tuple.

\begin{center}
  \begin{lstlisting}[language=Haskell]
    fBad2 :: (Char, Int) -> (Char, Int)
    fBad2 (c, i) = (c, if ord c > 31 then 1 else 0)
  \end{lstlisting}
\end{center}
would give information about whether or not the variable \textbf{c} is a printable character (the ASCII values of printable characters start at 32~\cite{ascii})~\cite{seclib}.

\section{Related Work}
\label{chapter:related}
There have been research within Information-Flow Control and libraries have been created in order to help enforce information flow policies and secure both confidentiality and integrity of the information. Some of the most influencial findings for this project will be described below.
\subsection{LIO}
LIO (Labeled IO) is a library created in Haskell for dynamic information flow control~\cite{lio-2011}.
\subsection{Seclib}
Seclib is a light-weight library for information flow control in Haskell~\cite{seclib, seclib_git}. Just as with the library created in this thesis, Seclib is based on monads and all private data lives within the created monad. However, compared to the library in this thesis, Seclib creates two different monads, \textbf{Sec} and \textbf{SecIO}, where SecIO is an extended IO monad (an IO monad wrapped around a Sec monad). Seclib was designed to be a small, lightweight library and consists, as of Jan. 29 2015, 342 lines of code.
\subsection{SeLINQ}

\subsection{Why another library?}
As has been explained in Chapter~\ref{chapter:related}, there are already working libraries for information flow control so why would another library be needed? Even though the current libraries are good, they lack one part - integration with another system. The library created for this thesis is supposed to close the gap between a static control for information flow control and already created tools for dynamic check of information flow control (JSFlow) and created tools for securing Javascript from the viewpoint of a type system. The created library will be able to be run in GHC if one wants to create a system strictly for Haskell but it should also be able to run the code with Haste and as a result get produced Javascript code which is tagged so JSFlow can dynamically track the information flow.
