\chapter{Future work}
No matter how satisfied one is, there is always more work that can be done. In this section, five different suggestions for how to proceed in the future will be presented. The suggestions are not only about how to make the library SwapIFC better, but also other potential work within the area of information flow control.

\section{Full communication for SwapIFC to JSFlow}

\section{More primitives for the library}
A library for a language is never completed until it easily supports the entire language. For SwapIFC, an easy yet time consuming extension would be to add classes and primitives for more standard classes of Haskell. Adding support for handling strings and lists within the Flow monad is a easy next step to do. However, adding a class for every standard Haskell class would be tedious, so looking more on if it is possible to have a more general class within the Flow monad and easily lift values into it could also be a good next step.

As of now, if a programmer want to use primitives for lists within a Flow instance he or she must write the entire function him/herself. This is something one should be able to assume that a library should handle. As of right now, it can be handled using Applicative. A very simple example of adding the primitive (++), which given two lists concatenates them, is
\begin{center}
  \begin{lstlisting}[language=Haskell]
    flowConcat :: Applicative f => f [a] -> f [a] -> f [a]
    flowConcat f1 f2 = (++) <$> f1 <*> f2
  \end{lstlisting}
\end{center}
However, it has a major drawback. Since it uses Applicative and there are two different Applicative implementations (one for High and one for Low), both flows (f1 and f2) must have the same tag. So as of right now, a programmer who uses SwapIFC must either implemement the missing primitives him/herself or accept that all operands must be of the same type (in this case the same tag).

\section{Add support for Haste.App}
When using Haste one can use Haste.App to perform program slicing~\cite{haste-symposium}. The point of the program slicing is to help the programmer to split the application between the server side and the client side. Haste.App introduces two monads, \textbf{App} and \textbf{Server} where App is the monad for the client side and Server the monad for the server side~\cite{haste-app}. When using Haste.App and compiling with Haste, the compiler will produce client side code (i.e. Javascript code) for everything in the App monad while producing a binary file for the server side for everything within the Server monad. This allows a programmer to write code as one application while during the compile phase have it split. Currently, SwapIFC does not support Haste.App. Even though it could work, no work has been done to support Haste.App and therefore a good idea in the future would be to look at Haste.App and ensure that SwapIFC does indeed support Haste.App.

\section{More features for Haste}
Better FFI, perhaps parsing a JS-library and add security labels..

\section{More features for JSFlow}
As JSFlow only supports ECMA-262 v5 in non-strict mode and does not support JSON (JavaScript Object Notation), a natural continuation would be to add and implement support for strict mode and JSON communication. Information flow control for JSON objects imposes a big challenge. JSON objects are used to simplify data transfer over a network and is both easy to read/write for humans and easy to parse for computers~\cite{json}. It consists of \emph{key, value} pairs, where a key (a string) is mapped to a value. An example of a simple JSON object is
\begin{lstlisting}[language=Java]
  {
    "firstName" : "Sherlock",
    "lastName" : "Holmes",
    "alive" : false,
    "children" : [],
    "address" : {
      "streetName" : "Backer Street",
      "streetNbr" : "221 B",
      "city" : "London",
      "country" : "England"
    },
    "spouse" : null
  }
\end{lstlisting}
where the key "firstName" is mapped to the string "Sherlock" and the key "address" is mapped to a JSON object containing the information about the address. The challenges from a information flow control viewpoint is \emph{"how to effectively guarantee that no private information is leaked through JSON objects?"}. It is easy to see it is not trivial to guarantee information flow security through JSON, but should be considered as a natural next step for a dynamic system designed to guarantee information flow control in Javascript.

Another feature for JSFlow would be to start add what is new in ECMA-262 v6, e.g. adding support for ArrayBuffer which represents a generic, fixed-length binary data buffer~\cite{js_arraybuffer}. Added support for HTML5 with Websockets and make it compatible to run in a browser should of course also be considered as important features to add.

\section{End-to-End information flow control}
JSFlow can help check the Javascript code of an application. However, currently there is no system that ensures a cross-origin end-to-end information flow control. As mentioned in Chapter~\ref{chapter:related}, work has been done to create good information flow control libraries in Haskell. An example is LMonad, which provided information flow control for Yesod, including database interactions. There has also been work on securing database communication in LINQ using F\# with SeLINQ~\cite{selinq}, which would help track information flow across the boundaries of applications and databases. As a proof of concept, a type checker for a subset of F\# was implemented. A good continuation would be to generalize the end-to-end communication. There are several ways this can be done.
\begin{itemize}
  \item Build a dynamic system for information flow control in back-end communication (e.g. database communication).
  \item Create a compiler which compiles from a high-level language to e.g. the database query language to guarantee type safety and use the aforementioned tool to guarantee run-time information flow control.
  \item Model the system in e.g. Haskell and enable the rich type system to create a static analysis of the model to ensure no information leakage occurs.
\end{itemize}
