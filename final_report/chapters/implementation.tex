\chapter{Implementation}
\label{chapter:implementation}
The implementation of the library consists of several modules which a user is allowed to use in order to create programs which are secure with regards to information flow control. The standard implementation of the library consists of a type \emph{Flow}, which is a flow in the program (i.e. data with a high or low tag). It also provides the user with standard operations, e.g. adding two flows if the flows are of such a type where addition is valid.

Currently, the library has a representation of all the standard operations within the following Haskell types:
\begin{itemize}
  \item Num
  \item Frac
  \item Bool
  \item Eq
  \item Ord
\end{itemize}

The Monad, Functor and Applicative instances for the High and Low Flow can be seen in Appendix~\ref{app:instances} and and example of how the standard operations for the Num type in Haskell can be found in Appendix~\ref{app:num_type}.
\section{The Flow type}
\label{sec:flow}
The Flow type is defined as a newtype in Haskell, i.e. a definition that can only contain one constructor. The Flow type became
\begin{center}
  \begin{lstlisting}[language=Haskell]
    newtype Flow tag a = Flow (IO a)
  \end{lstlisting}
\end{center}
and even though it has a tag in the definition (the left hand side), it does not contain a tag on the right hand side. Instead, the tag is implemented as a phantom type~\cite{haskell_phantom} which means that it can be checked by the type checker but not looked at by the user via e.g. pattern-matching. This means that from a user standpoint, the Flow type is simply a container for IO actions and the rules for the information flow control rules are implemented in the type checker alone. An example of how to add five to a Flow of High value is
\begin{center}
  \begin{lstlisting}[language=Haskell]
    addFiveFlow :: Flow High Int -> Flow High Int
    addFiveFlow f = do
      let b = mkHigh 5
      f .+. b
  \end{lstlisting}
\end{center}
where a new Flow (the variable \emph{b}) is created and added with the given Flow \emph{f}.

\subsection{Monad instance}
Two separate monad instances was created in order to be able to handle potential code generation towards Haste, one for High and one for Low flow. If Haste was the compiler, then the High flow needed to be compiled with a call to the \emph{upg} function in JSFlow.

Every Monad created in Haskell must also be a Functor and an Applicative by the Functor-Applicative-Monad proposal~\cite{functor_applicative_monad}. Starting from GHC 7.10, every Monad that is not a Functor or Applicative will generate a compile error. Due to the Functor-Applicative-Monad proposal, the created Monad for the Flow type is a Functor and an Applicative as well.

\subsection{Functor instance}
\begin{center}
  \begin{lstlisting}[language=Haskell]
    fmap f ioa = ioa >>= return . f
  \end{lstlisting}
\end{center}

\subsection{Applicative instance}
The Applicative instance is implemented simply by using primitives from the Monad class by having
\begin{center}
  \begin{lstlisting}[language=Haskell]
    pure  = return
    (<*>) = ap
  \end{lstlisting}
\end{center}

\section{Controlling the flow}
Even though there are only two types of tags for the flow, they need to be thoroughly controlled. It is possible to use type variables when creating a class instance in Haskell. In the case for the class \emph{FlowBool}, i.e. a class that contains all operations for the Haskell type Bool wrapped in the Flow type, it is created as
\begin{center}
  \begin{lstlisting}[language=Haskell]
    class FlowBool t1 t2 t3 | t1 t2 -> t3 where
      -- Function implementations of boolean operators
  \end{lstlisting}
\end{center}
where t1, t2 and t3 are type variables. As can be seen, given two tags, t1 and t2, it is possible to derive the resulting tag t3. In order for Haskell to know how the different type variables relate to eachother, instance definitions must be added:
\begin{center}
  \begin{lstlisting}[language=Haskell]
    instance FlowBool High High High
    instance FlowBool High Low High
    instance FlowBool Low High High
    instance FlowBool Low Low Low
  \end{lstlisting}
\end{center}
The instance definitions give the rules for the Haskell type system which types the type variables can have and how to derive the resulting type. As can be seen, the only way for a \emph{FlowBool} to produce something of low value is when the two type variables t1 and t2 are low. As soon as either t1 or t2 or both are high, the result will be high. This holds for all classes in the library.

\section{Handling side effects}
Handling side effects in any language is a challenge from a security point of view. Potential shared states can be altered, data can be printed or exceptions could be thrown indicating an error has occurred. From the viewpoint of information flow control, all of these side effects must be monitored closely.

\subsection{JSFlow and side effects}

\subsection{Side effects in the library}
The function that will handle the side effects has the following implementation:
\begin{center}
  \begin{lstlisting}[language=Haskell]
    runFlow :: Flow t () -> IO ()
    runFlow (Flow ioa) = do
      res <- try ioa
      case res of
        Left err -> let e = err :: SomeException
                    in return ()
        Right () -> return ()
  \end{lstlisting}
\end{center}
As can be seen, the implementation uses Haskell's Unit-type.

Mention unit type - Correlates to void in e.g. Java.
What should be allowed and how to do it?
Stricter compared to JSFlow?
What can JSFlow do?
Check out side effects in LIO.

\section{Incorporating with Haste}
In order to incorporate the library with Haste, a communication between the library and Haste had to be created. This was done by using a preprocessing directive, the same preprocessing directive that Haste will set if the compilation process is done with Haste. The key difference for how the library should behave between GHC and Haste is the \emph{return} of the high flow within the Monad instance. The main difference is highlighted in the following code snippet:
\begin{center}
  \begin{lstlisting}[language=Haskell]
    #ifdef __HASTE__
      return = Flow . upg
    #else
      return = Flow . return
    #endif
  \end{lstlisting}
\end{center}
If the program is compiled with Haste, then the computation given to return will be executed within the function upg
\begin{center}
  \begin{lstlisting}[language=Haskell]
    upg :: a -> IO a
    upg = fmap fromOpaque . ffi "upg" . toOpaque
  \end{lstlisting}
\end{center}
which makes a FFI (Foreign Function Interface) call in order to wrap the compiled JavaScript code with a call to the JSFlow function upg. It is made opaque in order to avoid any optimizations from the compiler. This process does not have to be done with a low flow type since it should be executed as normal code by JSFlow. The full implementation of the Monad instance can be seen in Appendix~\ref{app:instances}.

The same principle as with \emph{upg} was used to implement \emph{lprint}, a function that prints the value and the corresponding tag in JSFlow. The function in SwapIFC which communicates with JSFlow was implemented as
\begin{center}
  \begin{lstlisting}[language=Haskell]
    lprintHaste :: Show a => a -> IO ()
    lprintHaste = ffi "lprint" . show
  \end{lstlisting}
\end{center}
Unfortunately, this solution combined with Haste will produce a corner case in Javascript. Haste will create a function (call it \emph{A} for apply) which in turn "builds" functions by function application. It takes a function (call it \emph{f}) and its arguments (call them \emph{args}) as argument and applies \emph{f} to \emph{args}. If \emph{f} expects more arguments then \emph{A} will return a closure waiting for the rest of the arguments. If there are more arguments in \emph{args} then \emph{f} will be applied with the expected arguments and the result will be applied to the rest of the arguments. Otherwise \emph{f} will be fully applied to \emph{args}. The way this is checked is by checking the length field of \emph{f}. Even though the arguments when declaring a function are optional to define, a function can take up to 255 arguments~\cite{js-function}. In the following example
\begin{center}
  \begin{lstlisting}[language=Java]
    function g() {
        lprint(arguments[0]);
    }
  \end{lstlisting}
\end{center}
the function \emph{g} takes an argument but it is not defined in the parameter list. But every function in Javascript have an argument object assiciated to it~\cite{js-arguments}, so calling \emph{g(42);} will indeed work since 42 will be at \emph{arguments[0]}. But checking the length field by calling \emph{g.length} will yield 0. This will cause a problem since the code generated from Haste will check
\begin{center}
  \begin{lstlisting}[language=Java]
    if(f.arity === undefined) {
        f.arity = f.length;
    }
  \end{lstlisting}
\end{center}
but if the function \emph{f} does not have variables in the arguments list, \emph{f.length} will be 0.

The way the problem with printing using \emph{lprint} was solved by supplying an anonymous function through the FFI like below:
\begin{center}
  \begin{lstlisting}[language=Haskell]
    lprintHaste :: Show a => a -> IO ()
    lprintHaste = ffi "(function(x){lprint(x);})" . show
  \end{lstlisting}
\end{center}
where the anonymous function has a variable in the arguments list. This means that the length of the function will be 1 and the problem explained above will not occur. 

\subsection{Modifications done to Haste}
Since JSFlow only supports ECMA-262 v5 in non-strict mode and does not support JSON~\cite{jsflow}, some modifications to Haste were needed in order to produce Javascript source code which followed the ECMA-262 v5 standard~\cite{ecma262v5}. The code generation of Haste needed to be altered in order to not produce code for the JSON library and ECMA features that are introduced in ECMA-262 v6. Haste allows for ArrayBuffers to be produced, but since the concept of ArrayBuffer is in draft mode for ECMA-262 v6~\cite{js_arraybuffer, ecma_arraybuffer} they can not be supported by the current version of JSFlow. However, since crippling every user of Haste by removing features is not a good idea, a flag was added in case a user wants to compile towards JSFlow. This means that Haste will produce Javascript source code with features that are introduced in ECMA-262 v6 unless the user tells the compiler to produce source code that can be dynamically checked by JSFlow.
