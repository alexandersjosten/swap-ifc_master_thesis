\section{Implementation}
\label{chapter:implementation}
The implementation of the library consists of several modules which a user is allowed to use in order to create programs which are secure with regards to information flow control. The standard implementation of the library consists of a type \emph{Flow}, which is a flow in the program (i.e. data with a high or low tag). It also provides the user with standard operations, e.g. adding two flows if the flows are of such a type where addition is valid.

Currently, the library has a representation of all the standard operations within the following Haskell types:
\begin{itemize}
  \item Num
  \item Frac
  \item Bool
  \item Eq and Ord
\end{itemize}

The Monad, Functor and Applicative instances for the High and Low Flow can be seen in Appendix~\ref{app:instances} and and example of how the standard operations for the Num type in Haskell can be found in Appendix~\ref{app:num_type}.
\subsection{The Flow type}
\label{sec:flow}
The Flow type is defined as a newtype in Haskell, i.e. a definition that can only contain one constructor. The Flow type became
\begin{lstlisting}[language=Haskell, xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
newtype Flow tag a = Flow (IO a)
\end{lstlisting}
and even though it has a tag in the definition (the left hand side), it does not contain a tag on the right hand side. Instead, the tag is implemented as a phantom type\cite{haskell_phantom} which means that it can be checked by the type checker but not looked at by the user via e.g. pattern-matching. This means that from a user standpoint, the Flow type is simply a container for IO actions and the rules for the information flow control rules are implemented in the type checker alone. An example of how to add five to a Flow of High value is
\begin{lstlisting}[language=Haskell]
addFiveFlow :: Flow High Int -> Flow High Int
addFiveFlow f = do
  let b = mkHigh 5
  f .+. b
\end{lstlisting}
where a new Flow (the variable \emph{b}) is created and added with the given Flow \emph{f}.
\subsubsection{Monad instance}
Two separate monad instances was created in order to be able to handle potential code generation towards Haste, one for High and one for Low flow. If Haste was the compiler, then the High flow needed to be compiled with a call to the \emph{upg} function in JSFlow.
\subsubsection{Functor instance}

\subsubsection{Applicative instance}
apofkapfokaspfok

\subsection{Handling side effects}
What should be allowed and how to do it?
Stricter compared to JSFlow?
What can JSFlow do?
Check out side effects in LIO.

\subsection{Incorporating with Haste}
How to do this?
