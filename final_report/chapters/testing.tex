\chapter{Testing of the implementation}
\label{chapter:testing}
The testing part of the project was done in two different ways. First, randomized tests of SwapIFC were done using QuickCheck~\cite{quickcheck, quickcheck-wiki}. Randomized testing is an area where a lot of research has been made.
\section{"Naïve" testing of the primitives}
One does not need to write randomized tests in order to test the primitives of the library. All that is needed is to write functions that captures every potential scenario. For the "add" primitive of two flows, the valid flows can be seen in Figure~\ref{fig:validFlow}.
\begin{figure}[h]
  \begin{center}
    \begin{lstlisting}[language=Haskell]
      testFlowNumLL :: Num a
                    => Flow Low a
                    -> Flow Low a
                    -> Flow Low a
      testFlowNumLL = (.+.)
    
      testFlowNumLH :: Num a
                    => Flow Low a
                    -> Flow High a
                    -> Flow High a
      testFlowNumLH = (.+.)
    
      testFlowNumHL :: Num a
                    => Flow High a
                    -> Flow Low a
                    -> Flow High a
      testFlowNumHL = (.+.)
    
      testFlowNumHH :: Num a
                    => Flow High a
                    -> Flow High a
                    -> Flow High a
      testFlowNumHH = (.+.)
    \end{lstlisting}
  \end{center}
  \caption{Valid flows for add primitive}
  \label{fig:validFlow}
\end{figure}
However, if one attempted any of the following flows that is present in Figure~\ref{fig:invalidFlow}, it would yield a compile time error due to the typeclass FlowNum not being defined for those cases. FlowNum is only defined to allow information flow like the ones in Figure~\ref{fig:validFlow}. This holds for every primitive in the library.
\begin{figure}[h]
  \begin{center}
    \begin{lstlisting}[language=Haskell]
      testFlowNumLL' :: Num a
                     => Flow Low a
                     -> Flow Low a
                     -> Flow High a
      testFlowNumLL' = (.+.)
    
      testFlowNumLH' :: Num a
                     => Flow Low a
                     -> Flow High a
                     -> Flow Low a
      testFlowNumLH' = (.+.)

      testFlowNumHL' :: Num a
                     => Flow High a
                     -> Flow Low a
                     -> Flow Low a
      testFlowNumHL' = (.+.)

      testFlowNumHH' :: Num a
                     => Flow High a
                     -> Flow High a
                     -> Flow Low a
      testFlowNumHH' = (.+.)
    \end{lstlisting}
  \end{center}
  \caption{Invalid flows for add primitive}
  \label{fig:invalidFlow}
\end{figure}
This is of course not a feasable solution and because of this, unit testing and random testing with QuickCheck was done.

\section{Unit testing}
A slightly more clever way of testing compared to the naîve testing described above is unit testing. The main principle of the unit testing is to isolate parts of a program or library and show its correctness by conducting tests on the specific part. For SwapIFC, the unit testing consisted of 202 tests which tested every primitive of the library. Given that all 202 tests yielded a correct result, the probability that the primitives behave correctly is considered high. However, unit testing is manual testing and it can be difficult to find edge cases and because of this, random tests using QuickCheck were also conducted.

\section{Testing of the library with QuickCheck}
In order to test SwapIFC with QuickCheck, every operator for the different Flow instances needed to be modeled as a constructor of a datatype. The probability distribution for each operator within an instance is the same. The general algorithm for the FlowNum instance tests can be seen in Figure~\ref{fig:testing_swapifc}. Note that the \emph{oneof} function is a function that will pick one of the elements in the list at a normal distribution and the \emph{randomInteger} function simply generates a random integer. The \emph{validate} function will return true if and only if the result of the operand \emph{op} applied to the flows \emph{flow1, flow2} will generate the same value as the normal operand corresponding to \emph{op} applied to the normal values corresponding to the flows, \emph{val1, val2} and if the tag is being preserved. The preservation of the tag means that if any of the operands have a High tag, then the result must be High. An example of this is the following:
\begin{center}
  \begin{lstlisting}[language=Haskell]
    let a = mkHigh 42
    let b = mkLow 10
    let c = a .+. b
    return (tag of c == High && value of c == 42 + 10)

    let d = mkLow 42
    let e = mkLow 10
    let f = a .<. b
    return (tag of f == Low && value of f == 42 < 10)
  \end{lstlisting}
\end{center}

The tags are only part of the type system and because of this some of the unsafe functions must be used in order to validate the tags. The unsafe functions used in the tests are \emph{unwrapValue} in order to check the computed flow value and \emph{unsafeShow} in order to get a string representation of the flow value. The string representation will be the value followed by "\_$<$T$>$", where T is either \emph{H} or \emph{L} for High and Low respectively. In the example above, \emph{unsafeShow a} will yield the string "42\_$<$H$>$" and \emph{unsafeShow d} will yield the string "42\_$<$L$>$".

Each test function is repeated 100000 times with random values and the source code for the FlowNum random tests can be found in Appendix~\ref{app:tests}.

\begin{figure}[h]
  \begin{algorithm}[H]
    \caption{Testing FlowNum in SwapIFC algorithm}
    \begin{algorithmic}
      \Function{TestNumBothLow}{}
      \State $op\gets oneof([Add, Sub, Mul, Neg, Abs, Sig])$
      \State $(val1, val2)\gets (randomInteger, randomInteger)$
      \State $flow1\gets mkLow(val1)$
      \State $flow2\gets mkLow(val2)$
      \State
      \Return Validate flow1 flow2 op val1 val2 Low
      \EndFunction

      \Function{TestNumBothHigh}{}
      \State $op\gets oneof([Add, Sub, Mul, Neg, Abs, Sig])$
      \State $(val1, val2)\gets (randomInteger, randomInteger)$
      \State $flow1\gets mkHigh(val1)$
      \State $flow2\gets mkHigh(val2)$
      \State
      \Return Validate flow1 flow2 op val1 val2 High
      \EndFunction

      \Function{TestNumMixedHighLow}{}
      \State $op\gets oneof([Add, Sub, Mul, Neg, Abs, Sig])$
      \State $(val1, val2)\gets (randomInteger, randomInteger)$
      \State $flow1\gets mkHigh(val1)$
      \State $flow2\gets mkLow(val2)$
      \State
      \Return Validate flow1 flow2 op val1 val2 High
      \EndFunction
    \end{algorithmic}
  \end{algorithm}
  \caption{Pseudo code for the testing of FlowNum in SwapIFC}
  \label{fig:testing_swapifc}
\end{figure}

\section{Testing of the code generation}
aosifjasofijasfoij
\begin{figure}[h]
  \begin{algorithm}[H]
    \caption{Testing JSFlow compatibility algorithm}
    \begin{algorithmic}
      \If {$c == 42$}
      \State $a\gets 10$
      \EndIf
    \end{algorithmic}
  \end{algorithm}
  \caption{Pseudo code for the testing of JSFlow}
  \label{fig:testing_jsflow}
\end{figure}
asodijasodijsd

\section{Argument for correctness of the library}
